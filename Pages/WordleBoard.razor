@using System.Text.RegularExpressions;
@using Microsoft.AspNetCore.Components.Forms

<div id="wordle-container" @onkeydown="KeyDown" tabindex="0">
    <div id="wordle-board">
        @if (boardReady)
        {
            @for (int guessNo = 0; guessNo < maxGuessCount; guessNo++)
            {
                <div class="row">
                    @for (int letterNo = 0; letterNo < word.Length; letterNo++)
                    {
                        <div class="@cellColors[guessNo,letterNo]">@GetCharacter(guessNo, letterNo)</div>
                    }
                </div>
            }
        }
    </div>

    <div id="wordle-input">

        <div class="row">
            @for (int j = 0; j < inputWord.Length; j++)
            {
                <div class="cell color-wrong">@inputWord[j]</div>
            }
            @if (inputWord.Length < word.Length)
            {
                @for (int j = 0; j < (word.Length - inputWord.Length); j++)
                {
                    <div class="cell color-wrong"></div>
                }
            }
        </div>
    </div>
</div>

@code {
    [Parameter]
    public int maxGuessCount { get; set; } = 6;
    public string inputWord { get; set; } = string.Empty;
    private string word = "APPLE";
    private string emptyGuess = "     ";
    private int guessesMade = 0;
    bool boardReady = false;
    List<string> guesses = new();
    Dictionary<int, List<char>> alreadyHintedLettersForGuess = new();
    string[,] cellColors;


    private void SetGuessColor(int guessNo)
    {
        string guess = guesses[guessNo];

        for (int j = 0; j < word.Length; j++)
        {
            char guessLetter = guess[j];

            if (word[j] == guessLetter)
            {
                cellColors[guessNo, j] = "cell color-correct";

                continue;
            }

            var posIndexes = AllIndexOf(word, guessLetter.ToString());
            var guessPosIndexes = AllIndexOf(guess, guessLetter.ToString());
            
            if (posIndexes.Count > 0)
            {
                // if first occurence of the guessLetter in the word is NOT correct
                foreach(var pos in posIndexes)
                {
                    if (guess[pos] != word[pos]) // letter is in there once, but not here, and it's not at the right spot, so set close color.
                    {
                        // if this letter has already been hinted as many times as it occurs in the word, don't hint again.
                        if (alreadyHintedLettersForGuess[guessNo].Where(l => l == guessLetter).Count() != word.Count(c => c == guessLetter))
                        {
                            alreadyHintedLettersForGuess[guessNo].Add(guessLetter);
                            cellColors[guessNo, j] = "cell color-close";
                            
                        }
                    }
                }

                // foreach (var pos in guessPosIndexes.Where(d => !posIndexes.Contains(d)))
                foreach (var pos in guessPosIndexes)
                {
                    if (guess[pos] != word[pos]) 
                    {
                        // if this letter has already been hinted as many times as it occurs in the word, don't hint again.
                        if (alreadyHintedLettersForGuess[guessNo].Where(l => l == guessLetter).Count() != (posIndexes.Count + guessPosIndexes.Count))
                        {
                            alreadyHintedLettersForGuess[guessNo].Add(guessLetter);
                            cellColors[guessNo, j] = "cell color-close";
                        }
                    }
                }
                continue;
            }
            cellColors[guessNo, j] = "cell color-wrong";           
        }
    }

    private void putGuess(string g)
    {
        int ind = guesses.IndexOf(emptyGuess);
        if (ind > -1)
        {

            guesses[ind] = inputWord;
            inputWord = string.Empty;

            SetGuessColor(ind);
            guessesMade++;

        }

    }

    protected void KeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "Enter":
                if (inputWord.Length == word.Length)
                {
                    putGuess(inputWord);
                }
                else
                {
                    // show shake animation
                }
                break;
            case "Backspace":
                if (inputWord.Length > 0)
                {
                    inputWord = inputWord.Remove(inputWord.Length - 1);
                }
                break;
            default:
                if (e.Key.Length == 1 && inputWord.Length < word.Length)
                {
                    inputWord += e.Key.ToUpper();
                }
                break;
        }
    }

    public IList<int> AllIndexOf(string text, string str, StringComparison comparisonType = StringComparison.InvariantCultureIgnoreCase)
    {
        IList<int> allIndexOf = new List<int>();
        int index = text.IndexOf(str, comparisonType);
        while (index != -1)
        {
            allIndexOf.Add(index);
            index = text.IndexOf(str, index + 1, comparisonType);
        }
        return allIndexOf;
    }


    char GetCharacter(int guessNo, int letterNo)
    {
        return guesses[guessNo][letterNo];
    }

    protected override Task OnInitializedAsync()
    {
        cellColors = new string[6, 6];
        for (int i = 0; i < 6; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                cellColors[i, j] = "cell color-wrong";
            }
        }

        guesses = Enumerable.Range(0, maxGuessCount).Select(_ => emptyGuess).ToList();
        Enumerable.Range(0, maxGuessCount).ToList().ForEach(i =>
        {
            alreadyHintedLettersForGuess.Add(i, new List<char>());
        });
        boardReady = true;
        return base.OnInitializedAsync();
    }
}
