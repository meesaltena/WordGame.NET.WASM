@using System.Text.RegularExpressions;
@using Microsoft.AspNetCore.Components.Forms

<div id="wordle-container" @onkeydown="KeyDown" tabindex="0">
    <div id="wordle-board">
        @if (boardReady)
        {
            @for (int guessNo = 0; guessNo < maxGuessCount; guessNo++)
            {
                <div class="row">
                    @for (int letterNo = 0; letterNo < word.Length; letterNo++)
                    {
                        <div class="@GetCellColor(guessNo,letterNo)">@GetCharacter(guessNo, letterNo)</div>
                    }
                </div>
            }
        }
    </div>

    <div id="wordle-input">

        <div class="row">
            @for (int j = 0; j < inputWord.Length; j++)
            {
                <div class="cell color-wrong">@inputWord[j]</div>
            }
            @if (inputWord.Length < word.Length)
            {
                @for (int j = 0; j < (word.Length - inputWord.Length); j++)
                {
                    <div class="cell color-wrong"></div>
                }
            }
        </div>
    </div>
</div>

@code {
    [Parameter]
    public int maxGuessCount { get; set; } = 6;
    public string inputWord { get; set; } = string.Empty;
    private string word = "AMPLE";
    private string emptyGuess = "     ";
    bool boardReady = false;
    List<string> guesses = new();    
    Dictionary<int, List<char>> alreadyHintedLettersForGuess = new();
    List<List<string>> cellColors = new();

    string GetCellColor(int guessNo, int letterNo)
    {
        var savedColor = cellColors[guessNo][letterNo];
        // if cell color is empty (true on startup) or guess with current guessNo is not empty, compute the needed cell color
        if (string.IsNullOrWhiteSpace(savedColor) || !string.IsNullOrWhiteSpace(guesses[guessNo]))
        {
            cellColors[guessNo][letterNo] = ComputeCellColor(guessNo, letterNo);
        }
        return cellColors[guessNo][letterNo];
    }

    string ComputeCellColor(int guessNo, int letterNo)
    {
 
        string guess = guesses[guessNo];


        char guessLetter = guess[letterNo];

        bool guessLetterAppears = word.Contains(guessLetter);


        var currentLetterMatchIndexes = AllIndexOf(word, guessLetter.ToString());


        // if letter doesn't appear, return wrong.
        if (!guessLetterAppears || string.IsNullOrWhiteSpace(guess))
        {
            return "cell color-wrong";
        }
        else // current guess letter appears in the word.
        {
            // if current guess letter appears in the word at the current position return correct.
            if(word[letterNo] == guessLetter)
            {
                Console.WriteLine($"guessLetter {guessLetter} appears in the correct position.");
                return "cell color-correct";
            }

            // if guessletter appears once in guess, and we are not there, return close.


            // if char appears multiple times in guess
            var guessLetterAppearancesInGuess = AllIndexOf(guess, guessLetter.ToString());
            var guessLetterAppearancesInWord = AllIndexOf(word, guessLetter.ToString());


            // if guessletter appears once in guess,
            if (guessLetterAppearancesInGuess.Count() == 1)
            {
                // if and we are not there, return close.
                Console.Write($"guessLetter {guessLetter} appears once in guess, ");
                if (guessLetterAppearancesInWord.First() != letterNo)
                {

                    Console.WriteLine($"but not here. returning close.");
                    return "cell color-close";
                }
                else
                {
                    Console.WriteLine($"and it's here?");
                }
            }



            var matches = guessLetterAppearancesInGuess.Intersect(guessLetterAppearancesInWord).ToList();
            // if any of the appearances of guessletter appear at the correct spot, and the spot is not the current letter, and the letter appears only once in the word, return wrong. 

            if (matches.Any())
            {
                // at least one appearance of the current letter, appears in the same spot in the word. 
                Console.WriteLine($"at least one appearance of the  guessLetter {guessLetter}, appears in the same spot in the word.");
                if (matches.Count() == 1) // the current guess letter appears in the word current position at least once. If we are not there currently, return wrong.
                {
                    Console.WriteLine($"Matches count == 1");

                    if (matches.First() != letterNo)
                    {
                        if (guessLetterAppearancesInWord.Count() > 1)
                        {
                            return "cell color-close";
                        }
                        return "cell color-wrong";
                    }
                    else
                    {
                        // the guessletter appears in the current location in the word. Correct.
                        Console.WriteLine($"the guessletter appears in the current location in the word. Correct.");
                        return "cell color-correct";
                    }
                    Console.WriteLine($"-----------");
                }
                else
                {
                    // the guessletter appears more than once in the word.
                    Console.WriteLine($"The guessLetter {guessLetter} appears more than once in the word.");

                    return "cell color-pink";
                }
            }
        }


        var gla = AllIndexOf(word, guessLetter.ToString());
        if (gla.Any())
        {
            if (!alreadyHintedLettersForGuess[guessNo].Contains(guessLetter))
            {
                alreadyHintedLettersForGuess[guessNo].Add(guessLetter);
                return "cell color-close";
            }
        }
        else
        {
        }

        return "cell color-none";
    }

    private void putGuess(string g)
    {
        int ind = guesses.IndexOf(emptyGuess);
        if (ind > -1)
        {
            guesses[ind] = inputWord;
            inputWord = string.Empty;
        }
    }

    protected void KeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "Enter":
                if (inputWord.Length == word.Length)
                {
                    putGuess(inputWord);
                }
                else
                {
                    // show shake animation
                }
                break;
            case "Backspace":
                if (inputWord.Length > 0)
                {
                    inputWord = inputWord.Remove(inputWord.Length - 1);
                }
                break;
            default:
                if (e.Key.Length == 1 && inputWord.Length < word.Length)
                {
                    inputWord += e.Key.ToUpper();
                }
                break;
        }
    }

    public IList<int> AllIndexOf(string text, string str, StringComparison comparisonType = StringComparison.InvariantCultureIgnoreCase)
    {
        IList<int> allIndexOf = new List<int>();
        int index = text.IndexOf(str, comparisonType);
        while (index != -1)
        {
            allIndexOf.Add(index);
            index = text.IndexOf(str, index + 1, comparisonType);
        }
        return allIndexOf;
    }


    char GetCharacter(int guessNo, int letterNo)
    {
        return guesses[guessNo][letterNo];
    }

    protected override Task OnInitializedAsync()
    {
        for (int n = 0; n < maxGuessCount; n++)
        {
            cellColors.Add(new List<string>());
        }

        for (int m = 0; m < cellColors.Count; m++)
        {
             for (int k = 0; k < maxGuessCount; k++)
            {
                cellColors[m].Add("");
            }
        }

        guesses = Enumerable.Range(0, maxGuessCount).Select(_ => emptyGuess).ToList();
        Enumerable.Range(0, maxGuessCount).ToList().ForEach(i =>
        {
            alreadyHintedLettersForGuess.Add(i, new List<char>());
        });
        boardReady = true;
        return base.OnInitializedAsync();
    }
}
