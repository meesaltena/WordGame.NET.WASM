@using System.Text.RegularExpressions;
@using Microsoft.AspNetCore.Components.Forms;
@using Wordle.NET.Models;

<div id="wordle-container" @onkeydown="KeyDown" tabindex="0">
    <div id="wordle-board">
            @for (int guessNo = 0; guessNo < maxGuessCount; guessNo++)
            {
            <div class="row guessrow" @ref="guessRefs[guessNo]">
                    @for (int letterNo = 0; letterNo < word.Length; letterNo++)
                    {
                        @if (guessNo < guesses.Count())
                        {
                            <div class="@guesses[guessNo].letters[letterNo].cssClass" style="@guesses[guessNo].letters[letterNo].cssStyle">
                                @guesses[guessNo].letters[letterNo]
                            </div>

                        }
                        else
                        {
                            <div class="cell color-wrong"></div>
                        }
                    }
            </div>
            }
    </div>

    <div id="wordle-input">
        <div class="row">
            @for (int j = 0; j < inputWord.Length; j++)
            {
                <div class="cell color-wrong">@inputWord[j]</div>
            }
            @if (inputWord.Length < word.Length)
            {
                @for (int j = 0; j < (word.Length - inputWord.Length); j++)
                {
                    <div class="cell color-wrong"></div>
                }
            }
        </div>
    </div>
</div>
<style>
    *:focus {
        outline: none;
    }
    .spin-anim {
        /* opacity: 1; */
        animation: spin 0.5s forwards;
    }
    .win-anim {
        /* opacity: 1; */

        animation: upanddown 0.5s forwards;
    }

    @@keyframes upanddown {
        0% {
            opacity: 1;
            transform: translateY(30%);
        }

        25% {
            transform: translateY(-30%);
        }

        50% {
            transform: translateY(-35%);
        }

        75% {
            opacity: 1;
            transform: translateY(15%);
        }

        100% {
            opacity: 1;
            transform: translateY(0%);
        }
    }

    @@keyframes spin {
        0% {
            opacity: 0;
            transform: rotateY(180deg);

        }

        100% {
            opacity: 1;
            transform: rotateY(0deg);
        }
    }
</style>

@code {
    [Parameter]
    public EventCallback<Guess> OnGuessesCallback { get; set; }
    [Parameter]
    public int maxGuessCount { get; set; } = 6;
    [Parameter]
    public bool showWonAnimation { get; set; } = false;
    public string inputWord { get; set; } = string.Empty;
    private string word = "APPLE";
    private bool boardReady = false;
    private bool won = false;
    private Dictionary<(int, int), string> letterClasses = new Dictionary<(int, int), string>();
    private Dictionary<int, ElementReference> guessRefs = new Dictionary<int, ElementReference>();
    List<Guess> guesses = new();
    private Dictionary<int, string> guessClasses = new();


    private async Task putGuess(string input)
    {
        if (guesses.Count() < maxGuessCount)
        {
            Guess g = new Guess(input, word);
            guesses.Add(g);
            inputWord = string.Empty;

            for(int i = 0; i < g.letters.Count(); i++)
            {

                await InvokeAsync(async () =>
                {
                    g.SetLetterColor(i);
                    g.SetSpinAnimation(i);
                    StateHasChanged(); // This is necessary to force the UI to update
                    await Task.Delay(300);
                });
            
                // await Task.Delay(300);
                // awaitawait Task.Delay(300);
                
                
            }

            if (g.IsCorrect())
            {

                foreach(Letter l in g.letters)
                {
                    l.animation = "win-anim";
                    // await InvokeAsync(() => StateHasChanged());
                    await Task.Delay(150);

                }

                await OnGuessesCallback.InvokeAsync(g);
            }

            
        }
    }

    protected async Task KeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "Enter":
                if (inputWord.Length == word.Length)
                {
                    await putGuess(inputWord);
                }
                else
                {
                    // show shake animation
                }
                break;
            case "Backspace":
                if (inputWord.Length > 0)
                {
                    inputWord = inputWord.Remove(inputWord.Length - 1);
                }
                break;
            default:
                if (e.Key.Length == 1 && inputWord.Length < word.Length)
                {
                    //TODO allow only a-z
                    inputWord += e.Key.ToUpper();
                    Console.WriteLine(inputWord);
                }
                break;
        }
    }

    protected override Task OnInitializedAsync()
    {
        guessClasses.Clear();
        boardReady = true;
        return base.OnInitializedAsync();
    }
}
